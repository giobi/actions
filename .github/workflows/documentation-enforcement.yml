name: Documentation Enforcement

on:
  workflow_call:
    inputs:
      days:
        description: "Number of days to look back for closed issues"
        required: false
        default: "14"
        type: string
      target_docs:
        description: "Comma-separated list of documentation files to target (readme.md, agents.md, docs/, help/, etc.)"
        required: false
        default: "readme.md,agents.md,docs/,help/"
        type: string
      dry_run:
        description: "Run in dry-run mode without creating issues"
        required: false
        default: false
        type: boolean
    secrets:
      OPENROUTER_API_KEY:
        description: "OpenRouter API key for AI analysis"
        required: false
    outputs:
      issues_analyzed:
        description: "Number of issues analyzed"
        value: ${{ jobs.analyze-and-enforce.outputs.issues_analyzed }}
      features_found:
        description: "Number of feature implementations found"
        value: ${{ jobs.analyze-and-enforce.outputs.features_found }}
      documentation_issue_created:
        description: "Whether a documentation update issue was created"
        value: ${{ jobs.analyze-and-enforce.outputs.documentation_issue_created }}
      documentation_issue_number:
        description: "Number of the created documentation issue"
        value: ${{ jobs.analyze-and-enforce.outputs.documentation_issue_number }}

jobs:
  analyze-and-enforce:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      pull-requests: read

    outputs:
      issues_analyzed: ${{ steps.enforce-docs.outputs.issues_analyzed }}
      features_found: ${{ steps.enforce-docs.outputs.features_found }}
      documentation_issue_created: ${{ steps.enforce-docs.outputs.documentation_issue_created }}
      documentation_issue_number: ${{ steps.enforce-docs.outputs.documentation_issue_number }}

    steps:
      - name: Analyze Issues and Enforce Documentation
        id: enforce-docs
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const daysBack = parseInt('${{ inputs.days }}');
            const targetDocs = '${{ inputs.target_docs }}';
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            
            // Calculate date threshold
            const dateThreshold = new Date();
            dateThreshold.setDate(dateThreshold.getDate() - daysBack);
            const since = dateThreshold.toISOString();
            
            console.log(`Analyzing issues since: ${since} (${daysBack} days ago)`);
            console.log(`Target documentation files: ${targetDocs}`);
            console.log(`Dry run mode: ${dryRun}`);
            
            // Fetch closed issues
            console.log('Fetching closed issues...');
            const { data: issues } = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'closed',
              since,
              per_page: 100,
              sort: 'updated',
              direction: 'desc'
            });
            
            // Filter out pull requests from issues
            const actualIssues = issues.filter(issue => !issue.pull_request);
            
            console.log(`Found ${actualIssues.length} closed issues to analyze`);
            
            if (actualIssues.length === 0) {
              console.log('No closed issues found in the specified time range. No documentation updates needed.');
              core.setOutput('issues_analyzed', 0);
              core.setOutput('features_found', 0);
              core.setOutput('documentation_issue_created', false);
              core.setOutput('documentation_issue_number', '');
              return;
            }
            
            // Prepare data for AI analysis
            const issuesData = actualIssues.map(issue => ({
              number: issue.number,
              title: issue.title,
              labels: issue.labels.map(label => label.name),
              closed_at: issue.closed_at,
              user: issue.user.login,
              body: issue.body ? issue.body.substring(0, 1000) : '' // Extended body for better analysis
            }));
            
            // Create prompt for AI to identify feature implementations
            const analysisPrompt = [
              'Analyze the following closed GitHub issues to identify FEATURE IMPLEMENTATIONS (not bug fixes or maintenance tasks).',
              'A feature implementation is a new functionality, enhancement, or capability added to the project.',
              'Bug fixes, refactoring, maintenance, dependency updates, and configuration changes are NOT feature implementations.',
              '',
              'For each issue, determine:',
              '1. Is this a feature implementation? (YES/NO)',
              '2. What type of feature is it? (API, UI, workflow, integration, etc.)',
              '3. What documentation areas might be affected?',
              '',
              'Return your analysis in this JSON format:',
              '{',
              '  "features_found": [',
              '    {',
              '      "issue_number": 123,',
              '      "title": "Issue title",',
              '      "is_feature": true,',
              '      "feature_type": "API",',
              '      "documentation_impact": ["readme.md", "docs/api.md"]',
              '    }',
              '  ],',
              '  "total_features": 1',
              '}',
              '',
              'ISSUES TO ANALYZE:',
              ...issuesData.map(issue => `#${issue.number}: ${issue.title}\nLabels: ${issue.labels.join(', ')}\nBody: ${issue.body}\n---`)
            ].join('\n');
            
            let analysisResult = null;
            let featuresFound = 0;
            
            // Analyze with AI if API key is available
            if ('${{ secrets.OPENROUTER_API_KEY }}') {
              console.log('Calling OpenRouter API for feature analysis...');
              
              try {
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${{ secrets.OPENROUTER_API_KEY }}`,
                    'Content-Type': 'application/json',
                    'HTTP-Referer': 'https://github.com',
                    'X-Title': 'Documentation Enforcement Analysis'
                  },
                  body: JSON.stringify({
                    model: 'anthropic/claude-3-haiku',
                    messages: [
                      {
                        role: 'user',
                        content: analysisPrompt
                      }
                    ],
                    max_tokens: 2000,
                    temperature: 0.1
                  })
                });
                
                if (!response.ok) {
                  throw new Error(`OpenRouter API failed: ${response.status} ${response.statusText}`);
                }
                
                const result = await response.json();
                const analysisText = result.choices[0].message.content;
                
                // Extract JSON from response
                const jsonMatch = analysisText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                  analysisResult = JSON.parse(jsonMatch[0]);
                  featuresFound = analysisResult.total_features || 0;
                  console.log(`AI analysis found ${featuresFound} feature implementations`);
                } else {
                  console.log('Could not parse AI analysis result, falling back to manual analysis');
                }
                
              } catch (error) {
                console.error('Failed to analyze with AI:', error);
                console.log('Falling back to manual analysis');
              }
            } else {
              console.log('No OpenRouter API key provided, using manual analysis');
            }
            
            // Fallback manual analysis if AI fails or no API key
            if (!analysisResult) {
              const featureKeywords = ['feature', 'add', 'implement', 'new', 'enhance', 'improvement'];
              const fixKeywords = ['fix', 'bug', 'error', 'issue', 'problem', 'broken'];
              
              const potentialFeatures = actualIssues.filter(issue => {
                const text = (issue.title + ' ' + (issue.body || '')).toLowerCase();
                const hasFeatureKeywords = featureKeywords.some(keyword => text.includes(keyword));
                const hasFixKeywords = fixKeywords.some(keyword => text.includes(keyword));
                
                // Prefer feature keywords, but exclude if it's clearly a fix
                return hasFeatureKeywords && !hasFixKeywords;
              });
              
              analysisResult = {
                features_found: potentialFeatures.map(issue => ({
                  issue_number: issue.number,
                  title: issue.title,
                  is_feature: true,
                  feature_type: 'General',
                  documentation_impact: targetDocs.split(',').map(doc => doc.trim())
                })),
                total_features: potentialFeatures.length
              };
              featuresFound = potentialFeatures.length;
              console.log(`Manual analysis found ${featuresFound} potential feature implementations`);
            }
            
            core.setOutput('issues_analyzed', actualIssues.length);
            core.setOutput('features_found', featuresFound);
            
            // If no features found, exit early
            if (featuresFound === 0) {
              console.log('No feature implementations found. No documentation updates needed.');
              core.setOutput('documentation_issue_created', false);
              core.setOutput('documentation_issue_number', '');
              return;
            }
            
            // Generate comprehensive documentation update prompt
            const documentationPrompt = [
              '# 📚 Documentation Update Required',
              '',
              `This issue was automatically created because ${featuresFound} feature implementation(s) were detected in recently closed issues.`,
              '',
              '## 🎯 Task for @copilot',
              '',
              '**You are tasked with updating the project documentation to reflect the following new features and implementations.**',
              '',
              '### Features Implemented:',
              ...analysisResult.features_found.map(feature => 
                `- **#${feature.issue_number}**: ${feature.title} (${feature.feature_type})`
              ),
              '',
              '### 📋 Documentation Update Checklist',
              '',
              '**Primary Documentation Files to Review and Update:**',
              ...targetDocs.split(',').map(doc => `- [ ] \`${doc.trim()}\``),
              '',
              '**Additional Documentation Areas to Consider:**',
              '- [ ] API documentation (if applicable)',
              '- [ ] Installation/setup guides',
              '- [ ] Usage examples and tutorials',
              '- [ ] Configuration documentation',
              '- [ ] Changelog/release notes',
              '- [ ] Architecture documentation',
              '- [ ] Developer guides',
              '',
              '### 🎨 Update Requirements',
              '',
              '**For each new feature, ensure documentation includes:**',
              '',
              '1. **Overview**: What the feature does and why it\'s useful',
              '2. **Setup/Installation**: How to enable or configure the feature',
              '3. **Usage Examples**: Practical examples showing how to use the feature',
              '4. **Configuration Options**: All available parameters and settings',
              '5. **Integration Notes**: How it works with existing features',
              '6. **Troubleshooting**: Common issues and solutions',
              '',
              '### 📝 Writing Guidelines',
              '',
              '- Use clear, concise language suitable for both beginners and experienced users',
              '- Include code examples where applicable',
              '- Maintain consistency with existing documentation style',
              '- Add appropriate headings and structure',
              '- Update table of contents if needed',
              '- Cross-reference related features and documentation sections',
              '',
              '### 🔍 Feature Details for Documentation',
              '',
              ...analysisResult.features_found.map(feature => [
                `#### Issue #${feature.issue_number}: ${feature.title}`,
                `- **Type**: ${feature.feature_type}`,
                `- **Suggested Documentation Impact**: ${feature.documentation_impact.join(', ')}`,
                `- **GitHub Issue**: [#${feature.issue_number}](../../issues/${feature.issue_number})`,
                ''
              ].join('\n')),
              '',
              '### ✅ Completion Criteria',
              '',
              '- [ ] All new features are properly documented',
              '- [ ] Examples are tested and working',
              '- [ ] Documentation is consistent and well-structured',
              '- [ ] Cross-references are updated',
              '- [ ] No broken links or references',
              '',
              '---',
              '',
              '**Auto-generated on:** ' + new Date().toLocaleString(),
              `**Analysis Period:** Last ${daysBack} days`,
              `**Issues Analyzed:** ${actualIssues.length}`,
              `**Features Found:** ${featuresFound}`,
              '',
              '*This issue was automatically created by the Documentation Enforcement workflow.*'
            ].join('\n');
            
            if (dryRun) {
              console.log('DRY RUN: Would create documentation issue with the following content:');
              console.log('--- Issue Title ---');
              console.log('📚 Documentation Update Required - New Features Detected');
              console.log('--- Issue Body ---');
              console.log(documentationPrompt);
              
              core.setOutput('documentation_issue_created', false);
              core.setOutput('documentation_issue_number', 'dry-run');
              return;
            }
            
            // Create the documentation update issue
            const issueTitle = '📚 Documentation Update Required - New Features Detected';
            
            console.log('Creating documentation update issue...');
            
            const newIssue = await github.rest.issues.create({
              owner,
              repo,
              title: issueTitle,
              body: documentationPrompt,
              labels: ['documentation', 'enhancement', 'copilot-task']
            });
            
            console.log(`Documentation issue created: #${newIssue.data.number}`);
            console.log(`URL: ${newIssue.data.html_url}`);
            
            core.setOutput('documentation_issue_created', true);
            core.setOutput('documentation_issue_number', newIssue.data.number);
            
            return {
              issueNumber: newIssue.data.number,
              issueUrl: newIssue.data.html_url,
              issuesAnalyzed: actualIssues.length,
              featuresFound: featuresFound
            };